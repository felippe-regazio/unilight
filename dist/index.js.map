{"version":3,"sources":["modules/parser.js","modules/formatter.js","modules/unilight.js","index.js"],"names":["module","exports","prev1","prev2","lastTokenType","multichar","text","options","pos","next1","chr","token","result","tokenType","length","push","t","formatKeyword","formatPonctuation","formatString","formatComment","RegExp","keywords","join","test","str","variant","flags","offsets","m","b","i","bi","c","bc","g","d","bg","s","bs","is","bis","o","on","p","q","qn","w","u","variantOffsets","special","forEach","String","fromCharCode","getFlag","flag","split","some","f","indexOf","type","getType","underline","strike","index","fromCodePoint","parse","require","format","unilight","highlight"],"mappings":"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","file":"index.js","sourceRoot":"../src","sourcesContent":["/**\n * This parse function is a modified version of the Microlight Parser,\n * Original microlight by asvd <heliosframework@gmail.com>\n * Original microlight repository: http://github.com/asvd/microlight\n * \n * This parser receives a code text and an options object. It will parse\n * the text and identify the different code elements. The code\n * elements are:\n * \n * Ponctuation\n * String\n * Comment\n * Neutral Scope\n * Keywords\n * \n * For each element a callback function will be called from { options }\n * object. The callbacks are:\n * \n * formatPonctuation(t) { ... }\n * formatString(t) { ... }\n * formatComment(t) { ... }\n * formatKeyword(t) { ... }\n * \n * Where <t> is the element found (a string). You can modify the string as you want it\n * and return the new modified string to compose the result.\n * \n * To define which keywords the parser must consider, you must pass the { options.keywords }\n * option with an string[]. eg.:\n * \n * [ 'const', 'var', 'let' ];\n * \n * Example of usage:\n * \n * parse('function test() { console.log(\"test\")}', {\n *   keywords: [ 'function', 'console' ],\n * \n *   formatKeyword(t) {\n *     // will find function and console\n *     // and will put it in uppercase\n *     // you must follow this example for\n *     // any kind of token modification\n *     return t.toUpperCase();\n *   },\n *   \n *   formatPonctuation(t) {\n *     return t;\n *   },\n *   \n *   formatString(t) {\n *     return t;\n *   },\n * \n *   formatComment(t) {\n *     return t;\n *   }\n * });\n * \n * Original microlight\n * @license MIT \n * @copyright 2016 asvd <heliosframework@gmail.com>\n *\n * Parse Function\n * @license MIT\n * @copyright 2022 Felippe Regazio <felippe.moraes@zoho.com>\n */\nmodule.exports = function parse(text = '', options = {}) {\n  var pos   = 0;       // current position\n  var next1 = text[0]; // next character\n  var chr   = 1;       // current character\n  var prev1;           // previous character\n  var prev2;           // the one before the previous\n  var token = '';      // current token content\n  var result = [];\n  \n  // current token type:\n  //  0: anything else (whitespaces / newlines)\n  //  1: operator or brace\n  //  2: closing braces (after which '/' is division not regex)\n  //  3: (key)word\n  //  4: regex\n  //  5: string starting with \"\n  //  6: string starting with '\n  //  7: xml comment  <!-- -->\n  //  8: multiline comment /* */\n  //  9: single-line comment starting with two slashes //\n  // 10: single-line comment starting with hash #\n  var tokenType = 0;\n  \n  // kept to determine between regex and division\n  var lastTokenType;\n  // flag determining if token is multi-character\n  var multichar;\n  \n  // running through characters and highlighting\n  while (prev2 = prev1,\n    // escaping if needed (with except for comments)\n    // pervious character will not be therefore\n    // recognized as a token finalize condition\n    prev1 = tokenType < 7 && prev1 == '\\\\' ? 1 : chr\n  ) {\n    chr = next1;\n    next1=text[++pos];\n    multichar = token.length > 1;\n    // checking if current token should be finalized\n    if (!chr  || // end of content\n      // types 9-10 (single-line comments) end with a\n      // newline\n      (tokenType > 8 && chr == '\\n') ||\n      [ // finalize conditions for other token types\n        // 0: whitespaces\n        /\\S/['test'](chr),  // merged together\n        // 1: operators\n        1,                // consist of a single character\n        // 2: braces\n        1,                // consist of a single character\n        // 3: (key)word\n        !/[$\\w]/['test'](chr),\n        // 4: regex\n        (prev1 == '/' || prev1 == '\\n') && multichar,\n        // 5: string with \"\n        prev1 == '\"' && multichar,\n        // 6: string with '\n        prev1 == \"'\" && multichar,\n        // 7: xml comment\n        text[pos-4]+prev2+prev1 == '-->',\n        // 8: multiline comment\n        prev2+prev1 == '*/'\n      ][tokenType]\n    ) {\n      // appending the token to the result\n      if (token) {\n        // remapping token type into style\n        // (some types are highlighted similarly)\n        result.push([\n          // 0: do not format\n          (t) => t,\n          // 1: keywords\n          options.formatKeyword,\n          // 2: punctuation\n          options.formatPonctuation,\n          // 3: strings and regexps\n          options.formatString,\n          // 4: comments\n          options.formatComment\n        ][\n          // not formatted\n          !tokenType ? 0 :\n          // punctuation\n          tokenType < 3 ? 2 :\n          // comments\n          tokenType > 6 ? 4 :\n          // regex and strings\n          tokenType > 3 ? 3 :\n          // otherwise tokenType == 3, (key)word\n          // (1 if regexp matches, 0 otherwise)\n          + new RegExp(`^(${options.keywords.join('|')})$`, 'i').test(token)\n        ](token));\n      }\n  \n      // saving the previous token type\n      // (skipping whitespaces and comments)\n      lastTokenType = (tokenType && tokenType < 7) ? tokenType : lastTokenType;\n  \n      // initializing a new token\n      token = '';\n  \n      // determining the new token type (going up the\n      // list until matching a token type start\n      // condition)\n      tokenType = 11;\n  \n      while (![\n        1, //  0: whitespace\n        //  1: operator or braces\n        /[\\/{}[(\\-+*=<>:;|\\\\.,?!&@~]/['test'](chr),\n        /[\\])]/['test'](chr),  //  2: closing brace\n        /[$\\w]/['test'](chr),  //  3: (key)word\n        chr == '/' &&        //  4: regex\n        // previous token was an\n        // opening brace or an\n        // operator (otherwise\n        // division, not a regex)\n        (lastTokenType < 2) &&\n        // workaround for xml\n        // closing tags\n        prev1 != '<',\n        chr == '\"', //  5: string with \"\n        chr == \"'\", //  6: string with '\n        //  7: xml comment\n        chr+next1+text[pos+1]+text[pos+2] == '<!--',\n        chr+next1 == '/*',   //  8: multiline comment\n        chr+next1 == '//',   //  9: single-line comment\n        chr == '#'           // 10: hash-style comment\n      ][--tokenType]);\n    }\n  \n    token += chr;\n  }\n\n  return result.join('');\n}","/**\n * (c) David Konrad 2018-\n * MIT License\n *\n * Javascript function to convert plain text to unicode variants\n *\n * Loosely based on the nodejs monotext CLI utility https://github.com/cpsdqs/monotext \n * (c) cpsdqs 2016\n *\n * For more inspiration see  http://unicode.org/charts/\n * Supported unicode variants\n *\n * m: monospace\n * b: bold\n * i: italic\n * c: script (Mathematical Alphanumeric Symbols)\n * g: gothic / fraktur\n * d: double-struck\n * s: sans-serif\n * o: circled text\n * p: parenthesized latin letters\n * q: squared text\n * w: fullwidth\n */\nmodule.exports = function toUnicodeVariant(str, variant, flags) {\n\tconst offsets = {\n\t\tm: [0x1d670, 0x1d7f6],\n\t\tb: [0x1d400, 0x1d7ce],\n\t\ti: [0x1d434, 0x00030],\n\t\tbi: [0x1d468, 0x00030],\n\t\tc: [0x0001d49c, 0x00030],\n\t\tbc: [0x1d4d0, 0x00030],\n\t\tg: [0x1d504, 0x00030],\n\t\td: [0x1d538, 0x1d7d8],\n\t\tbg: [0x1d56c, 0x00030],\n\t\ts: [0x1d5a0, 0x1d7e2],\n\t\tbs: [0x1d5d4, 0x1d7ec],\n\t\tis: [0x1d608, 0x00030],\n\t\tbis: [0x1d63c, 0x00030],\n\t\to: [0x24B6, 0x2460],\n\t\ton: [0x0001f150, 0x2460],\n\t\tp: [0x249c, 0x2474],\n\t\tq: [0x1f130, 0x00030],\n\t\tqn: [0x0001F170, 0x00030],\n\t\tw: [0xff21, 0xff10],\n\t\tu: [0x2090, 0xff10]\n\t}\n\n\tconst variantOffsets = {\n\t\t'monospace': 'm',\n\t\t'bold' : 'b',\n\t\t'italic' : 'i',\n\t\t'bold italic' : 'bi',\n\t\t'script': 'c',\n\t\t'bold script': 'bc',\n\t\t'gothic': 'g',\n\t\t'gothic bold': 'bg',\n\t\t'doublestruck': 'd',\n\t\t'sans': 's',\n\t\t'bold sans' : 'bs',\n\t\t'italic sans': 'is',\n\t\t'bold italic sans': 'bis',\n\t\t'parenthesis': 'p',\n\t\t'circled': 'o',\n\t\t'circled negative': 'on',\n\t\t'squared': 'q',\n\t\t'squared negative': 'qn',\n\t\t'fullwidth': 'w'\n\t}\n\n\t// special characters (absolute values)\n\tconst special = {\n\t\tm: {\n\t\t\t' ': 0x2000,\n\t\t\t'-': 0x2013\n\t\t},\n\t\ti: {\n\t\t\t'h': 0x210e\n\t\t},\n\t\tg: {\n\t\t\t'C': 0x212d,\n\t\t\t'H': 0x210c,\n\t\t\t'I': 0x2111,\n\t\t\t'R': 0x211c,\n\t\t\t'Z': 0x2128\n\t\t},\n    d: {\n      'C': 0x2102,\n      'H': 0x210D,\n      'N': 0x2115,\n      'P': 0x2119,\n      'Q': 0x211A,\n      'R': 0x211D,\n      'Z': 0x2124\n    },\n\t\to: {\n\t\t\t'0': 0x24EA,\n\t\t\t'1': 0x2460,\n\t\t\t'2': 0x2461,\n\t\t\t'3': 0x2462,\n\t\t\t'4': 0x2463,\n\t\t\t'5': 0x2464,\n\t\t\t'6': 0x2465,\n\t\t\t'7': 0x2466,\n\t\t\t'8': 0x2467,\n\t\t\t'9': 0x2468,\n\t\t},\n\t\ton: {},\n\t\tp: {},\n\t\tq: {},\n\t\tqn: {},\n\t\tw: {}\n\t}\n\t//support for parenthesized latin letters small cases \n\t//support for full width latin letters small cases \n\t//support for circled negative letters small cases \n\t//support for squared letters small cases \n\t//support for squared letters negative small cases \n\t;['p', 'w', 'on', 'q', 'qn'].forEach(t => {\n\t\tfor (var i = 97; i <= 122; i++) {\n\t\t\tspecial[t][String.fromCharCode(i)] = offsets[t][0] + (i-97)\n\t\t}\n\t})\t\t\n\n\tconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n\tconst numbers = '0123456789'\n\n\tconst getType = function(variant) {\n\t\tif (variantOffsets[variant]) return variantOffsets[variant]\n\t\tif (offsets[variant]) return variant\n\t\treturn 'm' //monospace as default\n\t}\n\tconst getFlag = function(flag, flags) {\n\t\tif (!flags) return false\n\t\treturn flag.split('|').some(f => flags.split(',').indexOf(f) > -1)\n\t}\n\n\tconst type = getType(variant)\n\tconst underline = getFlag('underline|u', flags)\n\tconst strike = getFlag('strike|s', flags)\n  let result = ''\n\n  for (let c of str) {\n    let index\n    if (special[type] && special[type][c]) c = String.fromCodePoint(special[type][c])\n    if (type && (index = chars.indexOf(c)) > -1) {\n      result += String.fromCodePoint(index + offsets[type][0]) \n    } else if (type && (index = numbers.indexOf(c)) > -1) {\n      result += String.fromCodePoint(index + offsets[type][1]) \n    } else {\n      result += c \n    }\n    if (underline) result += '\\u0332' // add combining underline\n    if (strike) result += '\\u0336' // add combining strike\n  }\n\treturn result\n}","const parse = require('./parser');\nconst format = require('./formatter');\n\n/**\n * This function receives a simple string and uses Unicode Variations\n * to highlight it. So we can have a rudimentary highlight for code\n * snippets almost in everywhere that accepts unicode text. The library \n * is capable to highlight any language since the \"keywords\" array is\n * dynamic.\n * \n * @license MIT\n * @copyright Felippe Regazio <felippe.moraes@zoho.com>\n * \n * @param {string} text \n * @param {string[]} keywords \n * @returns A unicode string with highlighted code\n */\nmodule.exports = function unilight(text, keywords = []) {\n  return parse(text, {\n    keywords,\n\n    formatKeyword(t) {\n      // return bold unicode\n      return format(t, 'bs');\n    },\n\n    formatPonctuation(t) {\n      // no formatting\n      return t;\n    },\n\n    formatString(t) {\n      // no formatting\n      return t;\n    },\n\n    formatComment(t) {\n      // return outlined unicode\n      return format(t, 'd');\n    }\n  });\n}","const unilight = module.exports = {\n  parse: require('./modules/parser'),\n  format: require('./modules/formatter'),\n  highlight: require('./modules/unilight')\n};\n"]}