// ğ”½ğ•šğ•« ğ•¦ğ•ğ•’ ğ•—ğ•–ğ•£ğ•£ğ•’ğ•ğ•–ğ•Ÿğ•¥ğ•’ ğ•¡ğ•£ğ•’ ğ•”ğ• ğ••ğ•– ğ•™ğ•šğ•˜ğ•™ğ•ğ•šğ•˜ğ•™ğ•¥ ğ•Ÿğ•  ğ•¥ğ•¨ğ•šğ•¥ğ•¥ğ•–ğ•£
// ğ•Šğ•–ğ•£ğ•§ğ•– ğ•¡ğ•£ğ•’ ğ•¢ğ•¦ğ•’ğ•ğ•¢ğ•¦ğ•–ğ•£ ğ•ğ•’ğ•Ÿğ•˜. ğ”»ğ•–ğ•¥ğ•’ğ•ğ•™ğ•–ğ•¤ ğ•Ÿğ•’ ğ•¥ğ•™ğ•£ğ•–ğ•’ğ•• ğŸ§¶

ğ—³ğ˜‚ğ—»ğ—°ğ˜ğ—¶ğ—¼ğ—» test() {
  ğ—°ğ—¼ğ—»ğ˜€ğ˜ a = "fizz";
  ğ—°ğ—¼ğ—»ğ˜€ğ˜ b = "buzz";
  ğ—¿ğ—²ğ˜ğ˜‚ğ—¿ğ—» a+b;
}

---

A ferramenta chama-se "Unilight". Consiste em um parser universal e um modulo que modifica a variaÃ§Ã£o unicode de partes da string.

Assim vc pode fazer highlight de cÃ³digo em qualquer lugar que nÃ£o aceite rich editing, basta ter uma string pura que aceita variaÃ§Ãµes unicode.

---

Existem 2 downsides nessa tecnica: 

1. O caractere unicode pode variar entre browsers ou sistemas operacionais.

2. A string vai ficar maior do que parece, pois modificadores unicode sÃ£o tbm chars invisÃ­veis. Assim, isso pode ser um problema em lugares que tem limitaÃ§Ã£o, como tt

---

Dito isso, uma vez que o output tenha suporte pra unicode, vc pode gerar cÃ³digos com highlighting em string pura no link abaixo:

---

